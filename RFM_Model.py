# -*- coding: utf-8 -*-
"""RFM_Model.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tvcfxCBoSTOzXVTeiVMFw4OU8QZDLCrZ
"""

import pandas as pd
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

!pip install plotly
import plotly.express as px
import plotly.graph_objects as go
!pip install scikit-learn-extra
from sklearn_extra.cluster import KMedoids
from scipy.cluster.hierarchy import dendrogram, linkage
from sklearn.cluster import AgglomerativeClustering
!pip install scikit-fuzzy
import numpy as np
import skfuzzy as fuzz
from sklearn.metrics import silhouette_score

# Load the data
file_path = 'RFMT.csv'
data = pd.read_csv(file_path)



# Select R, F, M columns for clustering
rfm_data = data[['R_Score', 'F_Score', 'M_Score']]

# Load the clustered data
file_path_new = 'customer_stat_cleaned.csv'
customer_stat_cleaned = pd.read_csv(file_path_new)
# compute correlation matrix
correlation_matrix = customer_stat_cleaned[['Transaction_Count', 'Days_Since_Last_Transaction', 'Average_Spending', 'Tenure']].corr()

correlation_matrix

# Calculate the within-cluster sum of square (wcss) for
# different number of clusters
kmeans_wcss = []
for i in range(1, 11):
    kmeans = KMeans(n_clusters=i, random_state=42)
    kmeans.fit(rfm_data)
    kmeans_wcss.append(kmeans.inertia_)

# Plot the elbow graph
plt.figure(figsize=(10, 6))
plt.plot(range(1, 11), kmeans_wcss, marker='o', linestyle='-')
plt.title('Elbow Method For Optimal k')
plt.xlabel('Number of clusters')
plt.ylabel('kmeans_WCSS')
plt.xticks(range(1, 11))
plt.grid(True)
plt.show()

# Apply K-means clustering with k = 4
kmeans = KMeans(init="random",
                n_clusters=4,
                n_init=10,
                max_iter=300,
                random_state=42)
kmeans_clusters = kmeans.fit_predict(rfm_data)

# Merge the datasets based on CustomerID
merged_data = pd.merge(data, customer_stat_cleaned, on='CustomerID')

# Add the cluster labels to the original data
merged_data['kmeans_Cluster'] = kmeans_clusters

# Calculate centroids for each cluster
kmeans_centroids = merged_data.groupby('kmeans_Cluster')[['Transaction_Count', 'Days_Since_Last_Transaction', 'Average_Spending']].mean()

# kmedoids elbow plot
kmedoids_pam_wcss = []
for i in range(1, 11):
    kmedoids_pam = KMedoids(n_clusters=i, method='pam',random_state=42)
    kmedoids_pam.fit(rfm_data)
    kmedoids_pam_wcss.append(kmedoids_pam.inertia_)

# Plot the elbow graph
plt.figure(figsize=(10, 6))
plt.plot(range(1, 11), kmedoids_pam_wcss, marker='o', linestyle='-')
plt.title('Elbow Method For Optimal k')
plt.xlabel('Number of clusters')
plt.ylabel('kmedoids_pam_WCSS')
plt.xticks(range(1, 11))
plt.grid(True)
plt.show()

# Apply K-medoid clustering with k = 4 and compute centroids
kmedoids_pam = KMedoids(n_clusters=4, method='pam', random_state=42)
kmedoids_pam_clusters = kmedoids_pam.fit_predict(rfm_data)
merged_data['kmedoids_pam_Cluster'] = kmedoids_pam_clusters
kmedoids_pam_centroids = merged_data.groupby('kmedoids_pam_Cluster')[['Transaction_Count', 'Days_Since_Last_Transaction', 'Average_Spending']].mean()

# Apply HAC
# linkage matrix
Z = linkage(rfm_data, method='ward')

# plot dendogram
plt.figure(figsize=(10, 7))
plt.title("Dendrogram")
dendrogram(Z)
plt.xlabel("Customers")
plt.ylabel("Euclidean distances")
plt.show()

# HAC bottom to up
agg_clustering = AgglomerativeClustering(n_clusters=4, affinity='euclidean', linkage='ward')
agg_clusters = agg_clustering.fit_predict(rfm_data)

# add labels to merged data
merged_data['agg_Cluster'] = agg_clusters
agg_centroids = merged_data.groupby('agg_Cluster')[['Transaction_Count', 'Days_Since_Last_Transaction', 'Average_Spending']].mean()

# perform Fuzzy C-Means
rfm_data_T = rfm_data.values.T
cntr, u, u0, d, jm, p, fpc = fuzz.cluster.cmeans(
    rfm_data_T, 4, 2, error=0.005, maxiter=1000, init=None)

# A range of the number of fuzzy cluster
cluster_range = range(2, 11)
fpcs = []


for n_clusters in cluster_range:
    # Apply fuzzy c means
    cntr, u, u0, d, jm, p, fpc = fuzz.cluster.cmeans(rfm_data.T, n_clusters, 2, error=0.005, maxiter=1000, init=None)
    fpcs.append(fpc)



# plot FPC figure
plt.figure(figsize=(8, 5))
plt.plot(cluster_range, fpcs, marker='o')
plt.title('Fuzzy Partition Coefficient (FPC) vs. Number of clusters')
plt.xlabel('Number of clusters')
plt.ylabel('Fuzzy Partition Coefficient (FPC)')
plt.grid(True)
plt.show()

# Get the cluster label with the maximum membership for each data point
fuzzy_cluster_labels = np.argmax(u, axis=0)

# Add cluster labels to the original data
merged_data['fuzzy_Cluster'] = fuzzy_cluster_labels

# Calculate the centroids of each cluster
fuzzy_centroids = merged_data.groupby('fuzzy_Cluster')[['Transaction_Count', 'Days_Since_Last_Transaction', 'Average_Spending']].mean()

# compute average silhouette score for algorithms
agg_silhouette_avg = silhouette_score(rfm_data, agg_clusters)
print(f'agg_Silhouette Score: {agg_silhouette_avg:.3f}')
kmedoids_pam_silhouette_avg = silhouette_score(rfm_data, kmedoids_pam_clusters)
print(f'kmedoids_pam_Silhouette Score: {kmedoids_pam_silhouette_avg:.3f}')
kmeans_silhouette_avg = silhouette_score(rfm_data, kmeans_clusters)
print(f'kmeans_Silhouette Score: {kmeans_silhouette_avg:.3f}')
fuzzy_silhouette_avg = silhouette_score(rfm_data_T.T, fuzzy_cluster_labels)
print(f'fuzzy_Silhouette Score: {fuzzy_silhouette_avg:.3f}')

# K means 3D Plotting
fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')

colors = ['r', 'g', 'b', 'y']

# Plot each cluster with different color
for cluster in range(4):
    kmeans_cluster_data = merged_data[merged_data['kmeans_Cluster'] == cluster]
    ax.scatter(kmeans_cluster_data['Transaction_Count'], kmeans_cluster_data['Days_Since_Last_Transaction'], kmeans_cluster_data['Average_Spending'],
               c=colors[cluster], label=f'kmeans_Cluster {cluster}', alpha=0.25)

# Calculate centroids for each cluster
kmeans_centroids = merged_data.groupby('kmeans_Cluster')[['Transaction_Count', 'Days_Since_Last_Transaction', 'Average_Spending']].mean()

# Plot the cluster centers
ax.scatter(kmeans_centroids['Transaction_Count'], kmeans_centroids['Days_Since_Last_Transaction'], kmeans_centroids['Average_Spending'],
           c='black', marker='X', s=200, alpha=1, label='kmeans_Centroids')

ax.set_xlabel('Transaction Count(F)')
ax.set_ylabel('Days Since Last Transaction(R)')
ax.set_zlabel('Average Spending(M)')

# Adjust the z-axis limit to fully display the range of values
ax.set_zlim(0, merged_data['Average_Spending'].max() + 500)

# Adjust legend position to avoid overlap
ax.legend(loc='upper left', bbox_to_anchor=(1.05, 1))

plt.title('3D kmeans_Cluster Plot')
plt.show()

merged_data.to_csv('RFM_clustered.csv', index=False)

# K means 3D interactive plot
# Create a 3D scatter plot
fig = px.scatter_3d(merged_data,
                    x='Transaction_Count',
                    y='Days_Since_Last_Transaction',
                    z='Average_Spending',
                    color='kmeans_Cluster',
                    title='3D Cluster Plot Based on Transactions',
                    range_x=[0, 300],
                    opacity=0.25)
# Add centroids to the plot
fig.add_trace(
    go.Scatter3d(
        x=kmeans_centroids['Transaction_Count'],
        y=kmeans_centroids['Days_Since_Last_Transaction'],
        z=kmeans_centroids['Average_Spending'],
        mode='markers',
        marker=dict(size=10, color='black', symbol='x'),
        name='kmeans_Centroids'
    )
)
fig.show()

# kmedoids 3D scatter plot
# Create a 3D scatter plot
fig = px.scatter_3d(merged_data,
                    x='Transaction_Count',
                    y='Days_Since_Last_Transaction',
                    z='Average_Spending',
                    color='kmedoids_pam_Cluster',
                    title='3D kmedoids_pam_Cluster Plot Based on Transactions',
                    range_x=[0, 300],
                    opacity=0.5)
# Add centroids to the plot
fig.add_trace(
    go.Scatter3d(
        x=kmedoids_pam_centroids['Transaction_Count'],
        y=kmedoids_pam_centroids['Days_Since_Last_Transaction'],
        z=kmedoids_pam_centroids['Average_Spending'],
        mode='markers',
        marker=dict(size=10, color='black', symbol='x'),
        name='kmedoids_pam_Centroids'
    )
)
fig.show()

# HAC 3D scatter plot

fig = px.scatter_3d(merged_data,
                    x='Transaction_Count',
                    y='Days_Since_Last_Transaction',
                    z='Average_Spending',
                    color='agg_Cluster',
                    title='3D plot based on Transaction Count(HAC)',
                    opacity=0.6)


fig.add_trace(
    go.Scatter3d(
        x=agg_centroids['Transaction_Count'],
        y=agg_centroids['Days_Since_Last_Transaction'],
        z=agg_centroids['Average_Spending'],
        mode='markers',
        marker=dict(size=10, color='black', symbol='x', opacity=0.8),
        name='agg_Centroids'
    )
)

# Fuzzy C 3D plot
fig = px.scatter_3d(merged_data,
                    x='Transaction_Count',
                    y='Days_Since_Last_Transaction',
                    z='Average_Spending',
                    color='fuzzy_Cluster',
                    title='3D plot based on Transaction (Fuzzy C-Means)',
                    opacity=0.6)


fig.add_trace(
    go.Scatter3d(
        x=fuzzy_centroids['Transaction_Count'],
        y=fuzzy_centroids['Days_Since_Last_Transaction'],
        z=fuzzy_centroids['Average_Spending'],
        mode='markers',
        marker=dict(size=10, color='black', symbol='x', opacity=0.8),
        name='Centroids'
    )
)